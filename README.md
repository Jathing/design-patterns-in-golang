## design-patterns-in-golang

![](https://raw.githubusercontent.com/ismayilmalik/golang-design-patterns/master/logo.png)

[菜鸟教程](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)


### 创建型模式分类

- [x] 单例模式

确保类只有一个实例，并提供对它的全局访问点。

- [x] 原型模式

指定使用原型实例创建的对象类型，并通过复制此原型创建新对象。

- [x] 工厂方法模式

定义用于创建对象的接口，但让子类决定实例化哪个类。工厂方法让类延迟实例化到子类。

- [x] 抽象工厂模式

提供一个接口，用于创建一系列相关或依赖的对象，而无需指定它们的具体类。

- [x] 建造者模式

将复杂对象的构造与其表示分离，以便相同的构造过程可以创建不同的表示。


### 结构型模式概述

- [x] 代理模式

一个类代表另一个类的功能，为其他对象提供一种代理以控制对这个对象的访问

- [x] 适配器模式

将类的接口转换为客户端期望的另一个接口。适配器使由于接口不兼容而无法在一起工作的类能够一起工作。

- [x] 桥接模式

将一个抽象从它的实现中解耦，这样两者可以独立地变化。

- [x] 装饰模式

动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活

- [x] 外观模式

为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

- [x] 享元模式

容器对象技术（IOC），用于减少创建对象的数量，以减少内存占用和提高性能，运用共享技术有效地支持大量细粒度的对象。

- [x] 组合模式

将对象组合成树结构来表示部分-整体层次结构。复合让客户端统一地对待单个对象和对象的组合。

### 行为型模式概述

- [x] 模板方法模式

在操作中定义算法的框架，将一些步骤延迟到子类。模板方法让子类在不改变算法结构的情况下重新定义算法的某些步骤。

- [x] 策略模式

定义一系列算法，封装每一个算法，并使它们可互换。策略让算法独立于使用它的客户而变化。

- [x] 命令模式

将请求封装为对象，从而使您可以用不同的请求对客户机进行参数化，并支持可撤消的操作。

- [x] 责任链模式

通过给多个对象一个处理请求的机会，避免将请求的发送者耦合到其接收者。链接接收对象，并将请求沿着链传递，直到对象处理该请求。

- [x] 状态模式

允许对象在其内部状态改变时改变其行为。对象将在更改其类时出现

- [x] 观察者模式

定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖关系都会被自动通知和更新

- [x] 中介者模式

定义封装一组对象如何交互的对象。中介通过防止对象显式地相互引用来促进松耦合，并且它允许您独立地改变它们的交互

- [x] 迭代器模式

提供按顺序访问聚合对象的元素而不公开其底层表示的方法。

- [x] 访问者模式

表示要在对象结构的元素上执行的操作。Visitor允许您定义新的操作，而无需更改操作的元素的类

- [x] 备忘录模式

在不违反封装的情况下，捕获并外部化对象的内部状态，以便稍后可以将对象恢复到此状态。

- [x] 解释器模式

给定一种语言，为其语法定义一种表示，以及使用该表示来解释该语言中的句子的解释器。